{"version":3,"file":"createSearchParams.js","sourceRoot":"","sources":["../../src/utils/createSearchParams.ts"],"names":[],"mappings":"AAQA,SAAS,sBAAsB,CAAC,IAAuC;IACrE,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAsB,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;QACjE,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;QACxB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;IACzF,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,UAAU,kBAAkB,CAAC,OAA4B,EAAE;IAC/D,MAAM,4BAA4B,GAChC,OAAO,IAAI,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,YAAY,eAAe,CAAC;IACrF,OAAO,IAAI,eAAe,CAAC,4BAA4B,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC,CAAC;AACjG,CAAC;AAED,MAAM,UAAU,0BAA0B,CACxC,cAAsB,EACtB,mBAA2C;IAE3C,MAAM,YAAY,GAAG,kBAAkB,CAAC,cAAc,CAAC,CAAC;IAExD,IAAI,mBAAmB,EAAE;QACvB,KAAK,IAAI,GAAG,IAAI,mBAAmB,CAAC,IAAI,EAAE,EAAE;YAC1C,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBAC1B,mBAAmB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;oBAChD,YAAY,CAAC,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;gBAClC,CAAC,CAAC,CAAC;aACJ;SACF;KACF;IAED,OAAO,YAAY,CAAC;AACtB,CAAC","sourcesContent":["export type ParamKeyValuePair = [string, string];\n\nexport type URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\nfunction convertObjectToURLInit(init: Record<string, string | string[]>) {\n  return Object.keys(init).reduce<ParamKeyValuePair[]>((memo, key) => {\n    const value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);\n  }, []);\n}\n\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nexport function createSearchParams(init: URLSearchParamsInit = ''): URLSearchParams {\n  const inputIsReadyForInstantiation =\n    typeof init === 'string' || Array.isArray(init) || init instanceof URLSearchParams;\n  return new URLSearchParams(inputIsReadyForInstantiation ? init : convertObjectToURLInit(init));\n}\n\nexport function getSearchParamsForLocation(\n  locationSearch: string,\n  defaultSearchParams: URLSearchParams | null,\n) {\n  const searchParams = createSearchParams(locationSearch);\n\n  if (defaultSearchParams) {\n    for (let key of defaultSearchParams.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n  }\n\n  return searchParams;\n}\n"]}