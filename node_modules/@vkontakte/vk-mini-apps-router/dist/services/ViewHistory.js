import { Action } from '@remix-run/router';
import { getRouteContext } from '../utils/utils';
import { STATE_KEY_SHOW_POPOUT } from '../const';
export class ViewHistory {
    constructor() {
        this.history = [];
        this.positionInternal = -1;
    }
    updateNavigation(state) {
        const record = this.getViewRecordFromState(state);
        if (!record) {
            return;
        }
        switch (state.historyAction) {
            case Action.Push:
                this.push(record);
                break;
            case Action.Pop:
                if (this.hasKey(record.locationKey)) {
                    this.pop(record);
                }
                else {
                    // В случае, если пользователь введет в адресную строку новый хэш, мы поймаем POP событие с новой локацией.
                    this.push(record);
                }
                break;
            case Action.Replace:
                this.replace(record);
                break;
        }
    }
    get isFirstPage() {
        return this.positionInternal < 1;
    }
    get panelsHistory() {
        if (this.positionInternal < 0) {
            return [];
        }
        const currentView = this.history[this.positionInternal].view;
        const reversedClone = this.history.slice(0, this.positionInternal + 1).reverse();
        const rightLimit = reversedClone.findIndex((item) => item.view !== currentView);
        const historyCopy = reversedClone
            .slice(0, rightLimit > -1 ? rightLimit : reversedClone.length)
            .filter((item) => !item.modal && !item.popout)
            .reverse();
        return historyCopy.map(({ panel }) => panel);
    }
    get position() {
        return this.positionInternal;
    }
    isPopForward(historyAction, key) {
        const newPosition = this.history.findIndex(({ locationKey }) => locationKey === key);
        return historyAction === Action.Pop && newPosition > this.position;
    }
    isPopBackward(historyAction, key) {
        const newPosition = this.history.findIndex(({ locationKey }) => locationKey === key);
        return historyAction === Action.Pop && newPosition <= this.position;
    }
    resetHistory() {
        this.positionInternal = -1;
        this.history = [];
    }
    push(record) {
        this.history = this.history.slice(0, this.positionInternal + 1);
        this.history.push(record);
        this.positionInternal = this.history.length - 1;
    }
    replace(record) {
        this.history[this.positionInternal] = record;
    }
    pop(record) {
        this.positionInternal = this.history.findIndex(({ locationKey }) => locationKey === record.locationKey);
    }
    hasKey(key) {
        return Boolean(this.history.find(({ locationKey }) => locationKey === key));
    }
    getViewRecordFromState(state) {
        const context = getRouteContext(state);
        if (!context.match) {
            return undefined;
        }
        const { route } = context.match;
        return {
            view: route.view,
            panel: route.panel,
            modal: 'modal' in route ? route.modal : undefined,
            popout: state.location.state?.[STATE_KEY_SHOW_POPOUT],
            locationKey: state.location.key,
        };
    }
}
//# sourceMappingURL=ViewHistory.js.map