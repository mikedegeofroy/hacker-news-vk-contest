import { createKey, fillParamsIntoPath, isModalShown, isPopoutShown } from '../utils/utils';
import { NAVIGATION_BLOCKER_KEY, STATE_KEY_BLOCK_FORWARD_NAVIGATION, STATE_KEY_SHOW_MODAL, STATE_KEY_SHOW_POPOUT, } from '../const';
import { hasNavigationOptionsKeys } from './RouteNavigator.type';
import { buildPanelPathFromModalMatch } from '../utils/buildPanelPathFromModalMatch';
import { NavigationTransaction } from '../entities/NavigationTransaction';
export class DefaultRouteNavigator {
    constructor(router, viewHistory, transactionExecutor, setPopout) {
        this.viewHistory = viewHistory;
        this.transactionExecutor = transactionExecutor;
        this.blockers = new Map();
        this.blockerId = 0;
        this.router = router;
        this.setPopout = setPopout;
    }
    async push(to, paramsOrOptions = {}, options = {}) {
        const paramsAreOptions = hasNavigationOptionsKeys(paramsOrOptions);
        const preparedOptions = paramsAreOptions ? paramsOrOptions : options;
        const fullOptions = {
            ...preparedOptions,
            replace: Boolean(this.router.state.location.state?.[STATE_KEY_BLOCK_FORWARD_NAVIGATION]),
        };
        const preparedParams = paramsAreOptions ? {} : paramsOrOptions;
        await this.navigate(to, fullOptions, preparedParams);
    }
    async replace(to, paramsOrOptions = {}, options = {}) {
        const paramsAreOptions = hasNavigationOptionsKeys(paramsOrOptions);
        const preparedOptions = paramsAreOptions ? paramsOrOptions : options;
        const preparedParams = paramsAreOptions ? {} : paramsOrOptions;
        await this.navigate(to, { ...preparedOptions, replace: true }, preparedParams);
    }
    async back(to = 1) {
        if (to === 0) {
            return;
        }
        await this.go(-Math.abs(to));
    }
    async backToFirst() {
        if (this.viewHistory.position > 0) {
            await this.go(-this.viewHistory.position);
        }
        else {
            await this.transactionExecutor.doNext();
        }
    }
    async go(to) {
        if (to === 0) {
            await this.transactionExecutor.doNext();
        }
        else {
            await this.router.navigate(to);
        }
    }
    runSync(actions) {
        const transaction = new NavigationTransaction(actions);
        this.transactionExecutor.add(transaction);
        this.transactionExecutor.doNext();
        return transaction.donePromise;
    }
    async showModal(id) {
        await this.router.navigate(this.router.state.location, {
            state: { [STATE_KEY_SHOW_MODAL]: id, [STATE_KEY_BLOCK_FORWARD_NAVIGATION]: true },
            replace: isModalShown(this.router.state.location),
        });
    }
    async hideModal(pushPanel = false) {
        if ((!pushPanel && !this.viewHistory.isFirstPage) || isModalShown(this.router.state.location)) {
            await this.router.navigate(-1);
        }
        else {
            const modalMatch = this.router.state.matches.find((match) => 'modal' in match.route);
            if (modalMatch) {
                const route = modalMatch.route;
                const path = buildPanelPathFromModalMatch(modalMatch, this.router);
                if (!path) {
                    const rootMessage = route.root ? `root: ${route.root} ` : '';
                    throw new Error(`There is no route registered for panel with ${rootMessage}, view: ${route.view}, panel: ${route.panel}.
Make sure this route exists or use hideModal with pushPanel set to false.`);
                }
                await this.navigate(path, { keepSearchParams: true });
            }
            else {
                await this.transactionExecutor.doNext();
            }
        }
    }
    async showPopout(popout) {
        this.setPopout(popout);
        const state = {
            [STATE_KEY_SHOW_POPOUT]: createKey(),
            [STATE_KEY_BLOCK_FORWARD_NAVIGATION]: true,
        };
        if (isModalShown(this.router.state.location)) {
            state[STATE_KEY_SHOW_MODAL] = this.router.state.location.state[STATE_KEY_SHOW_MODAL];
        }
        const replace = isModalShown(this.router.state.location) || isPopoutShown(this.router.state.location);
        await this.router.navigate(this.router.state.location, { state, replace });
    }
    async hidePopout() {
        if (isPopoutShown(this.router.state.location)) {
            this.setPopout(null);
            if (isModalShown(this.router.state.location)) {
                await this.router.navigate(this.router.state.location, {
                    state: {
                        [STATE_KEY_BLOCK_FORWARD_NAVIGATION]: true,
                        [STATE_KEY_SHOW_MODAL]: this.router.state.location.state[STATE_KEY_SHOW_MODAL],
                    },
                    replace: true,
                });
            }
            else {
                await this.router.navigate(-1);
            }
        }
        else {
            await this.transactionExecutor.doNext();
        }
    }
    block(blocker) {
        const key = (++this.blockerId).toString();
        this.blockers.set(key, blocker);
        const onLeave = (data) => {
            return Array.from(this.blockers.values()).some((fn) => fn(data));
        };
        this.router.getBlocker(NAVIGATION_BLOCKER_KEY, onLeave);
        return () => {
            this.blockers.delete(key);
        };
    }
    async navigate(to, opts, params = {}) {
        // prettier-ignore
        let path = typeof to === 'string'
            ? to
            : to.hasParams
                ? fillParamsIntoPath(to.path, params)
                : to.path;
        if (opts?.keepSearchParams) {
            path += this.router.state.location.search;
        }
        await this.router.navigate(path, opts);
    }
}
//# sourceMappingURL=DefaultRouteNavigator.js.map