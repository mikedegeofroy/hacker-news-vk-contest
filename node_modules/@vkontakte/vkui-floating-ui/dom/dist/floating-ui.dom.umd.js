"use strict";
var _async_to_generator = require("@swc/helpers/_/_async_to_generator");
var _instanceof = require("@swc/helpers/_/_instanceof");
var _object_spread = require("@swc/helpers/_/_object_spread");
var _object_spread_props = require("@swc/helpers/_/_object_spread_props");
var _sliced_to_array = require("@swc/helpers/_/_sliced_to_array");
var _to_consumable_array = require("@swc/helpers/_/_to_consumable_array");
var _ts_generator = require("@swc/helpers/_/_ts_generator");
(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require('../../core/dist/floating-ui.core.umd.js')) : typeof define === "function" && define.amd ? define([
        "exports",
        '../../core/dist/floating-ui.core.umd.js'
    ], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));
})(void 0, function(exports1, core) {
    "use strict";
    /**
   * Custom positioning reference element.
   * @see https://floating-ui.com/docs/virtual-elements
   */ var min = Math.min;
    var max = Math.max;
    var round = Math.round;
    var floor = Math.floor;
    var createCoords = function(v) {
        return {
            x: v,
            y: v
        };
    };
    function getNodeName(node) {
        if (isNode(node)) {
            return (node.nodeName || "").toLowerCase();
        }
        // Mocked nodes in testing environments may not be instances of Node. By
        // returning `#document` an infinite loop won't occur.
        // https://github.com/floating-ui/floating-ui/issues/2317
        return "#document";
    }
    function getWindow(node) {
        var _node$ownerDocument;
        return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
    }
    function getDocumentElement(node) {
        var _ref;
        return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
    }
    function isNode(value) {
        return _instanceof._(value, Node) || _instanceof._(value, getWindow(value).Node);
    }
    function isElement(value) {
        return _instanceof._(value, Element) || _instanceof._(value, getWindow(value).Element);
    }
    function isHTMLElement(value) {
        return _instanceof._(value, HTMLElement) || _instanceof._(value, getWindow(value).HTMLElement);
    }
    function isShadowRoot(value) {
        // Browsers without `ShadowRoot` support.
        if (typeof ShadowRoot === "undefined") {
            return false;
        }
        return _instanceof._(value, ShadowRoot) || _instanceof._(value, getWindow(value).ShadowRoot);
    }
    function isOverflowElement(element) {
        var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY, display = _getComputedStyle.display;
        return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![
            "inline",
            "contents"
        ].includes(display);
    }
    function isTableElement(element) {
        return [
            "table",
            "td",
            "th"
        ].includes(getNodeName(element));
    }
    function isContainingBlock(element) {
        var webkit = isWebKit();
        var css = getComputedStyle(element);
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || [
            "transform",
            "perspective",
            "filter"
        ].some(function(value) {
            return (css.willChange || "").includes(value);
        }) || [
            "paint",
            "layout",
            "strict",
            "content"
        ].some(function(value) {
            return (css.contain || "").includes(value);
        });
    }
    function getContainingBlock(element) {
        var currentNode = getParentNode(element);
        while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){
            if (isContainingBlock(currentNode)) {
                return currentNode;
            }
            currentNode = getParentNode(currentNode);
        }
        return null;
    }
    function isWebKit() {
        if (typeof CSS === "undefined" || !CSS.supports) return false;
        return CSS.supports("-webkit-backdrop-filter", "none");
    }
    function isLastTraversableNode(node) {
        return [
            "html",
            "body",
            "#document"
        ].includes(getNodeName(node));
    }
    function getComputedStyle(element) {
        return getWindow(element).getComputedStyle(element);
    }
    function getNodeScroll(element) {
        if (isElement(element)) {
            return {
                scrollLeft: element.scrollLeft,
                scrollTop: element.scrollTop
            };
        }
        return {
            scrollLeft: element.pageXOffset,
            scrollTop: element.pageYOffset
        };
    }
    function getParentNode(node) {
        if (getNodeName(node) === "html") {
            return node;
        }
        var result = // Step into the shadow DOM of the parent of a slotted node.
        node.assignedSlot || // DOM Element detected.
        node.parentNode || // ShadowRoot detected.
        isShadowRoot(node) && node.host || // Fallback.
        getDocumentElement(node);
        return isShadowRoot(result) ? result.host : result;
    }
    function getNearestOverflowAncestor(node) {
        var parentNode = getParentNode(node);
        if (isLastTraversableNode(parentNode)) {
            return node.ownerDocument ? node.ownerDocument.body : node.body;
        }
        if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
            return parentNode;
        }
        return getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list, traverseIframes) {
        var _node$ownerDocument2;
        if (list === void 0) {
            list = [];
        }
        if (traverseIframes === void 0) {
            traverseIframes = true;
        }
        var scrollableAncestor = getNearestOverflowAncestor(node);
        var isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
        var win = getWindow(scrollableAncestor);
        if (isBody) {
            return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
        }
        return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
    }
    function getCssDimensions(element) {
        var css = getComputedStyle(element);
        // In testing environments, the `width` and `height` properties are empty
        // strings for SVG elements, returning NaN. Fallback to `0` in this case.
        var width = parseFloat(css.width) || 0;
        var height = parseFloat(css.height) || 0;
        var hasOffset = isHTMLElement(element);
        var offsetWidth = hasOffset ? element.offsetWidth : width;
        var offsetHeight = hasOffset ? element.offsetHeight : height;
        var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
        if (shouldFallback) {
            width = offsetWidth;
            height = offsetHeight;
        }
        return {
            width: width,
            height: height,
            $: shouldFallback
        };
    }
    function unwrapElement(element) {
        return !isElement(element) ? element.contextElement : element;
    }
    function getScale(element) {
        var domElement = unwrapElement(element);
        if (!isHTMLElement(domElement)) {
            return createCoords(1);
        }
        var rect = domElement.getBoundingClientRect();
        var _getCssDimensions = getCssDimensions(domElement), width = _getCssDimensions.width, height = _getCssDimensions.height, $ = _getCssDimensions.$;
        var x = ($ ? round(rect.width) : rect.width) / width;
        var y = ($ ? round(rect.height) : rect.height) / height;
        // 0, NaN, or Infinity should always fallback to 1.
        if (!x || !Number.isFinite(x)) {
            x = 1;
        }
        if (!y || !Number.isFinite(y)) {
            y = 1;
        }
        return {
            x: x,
            y: y
        };
    }
    var noOffsets = /*#__PURE__*/ createCoords(0);
    function getVisualOffsets(element) {
        var win = getWindow(element);
        if (!isWebKit() || !win.visualViewport) {
            return noOffsets;
        }
        return {
            x: win.visualViewport.offsetLeft,
            y: win.visualViewport.offsetTop
        };
    }
    function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
        if (isFixed === void 0) {
            isFixed = false;
        }
        if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
            return false;
        }
        return isFixed;
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
        if (includeScale === void 0) {
            includeScale = false;
        }
        if (isFixedStrategy === void 0) {
            isFixedStrategy = false;
        }
        var clientRect = element.getBoundingClientRect();
        var domElement = unwrapElement(element);
        var scale = createCoords(1);
        if (includeScale) {
            if (offsetParent) {
                if (isElement(offsetParent)) {
                    scale = getScale(offsetParent);
                }
            } else {
                scale = getScale(element);
            }
        }
        var visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
        var x = (clientRect.left + visualOffsets.x) / scale.x;
        var y = (clientRect.top + visualOffsets.y) / scale.y;
        var width = clientRect.width / scale.x;
        var height = clientRect.height / scale.y;
        if (domElement) {
            var win = getWindow(domElement);
            var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
            var currentIFrame = win.frameElement;
            while(currentIFrame && offsetParent && offsetWin !== win){
                var iframeScale = getScale(currentIFrame);
                var iframeRect = currentIFrame.getBoundingClientRect();
                var css = getComputedStyle(currentIFrame);
                var left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
                var top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
                x *= iframeScale.x;
                y *= iframeScale.y;
                width *= iframeScale.x;
                height *= iframeScale.y;
                x += left;
                y += top;
                currentIFrame = getWindow(currentIFrame).frameElement;
            }
        }
        return core.rectToClientRect({
            width: width,
            height: height,
            x: x,
            y: y
        });
    }
    var topLayerSelectors = [
        ":popover-open",
        ":modal"
    ];
    function topLayer(floating) {
        var isTopLayer = false;
        var x = 0;
        var y = 0;
        function setIsTopLayer(selector) {
            try {
                isTopLayer = isTopLayer || floating.matches(selector);
            } catch (e) {}
        }
        topLayerSelectors.forEach(function(selector) {
            setIsTopLayer(selector);
        });
        if (isTopLayer) {
            var containingBlock = getContainingBlock(floating);
            if (containingBlock) {
                var rect = containingBlock.getBoundingClientRect();
                x = rect.x;
                y = rect.y;
            }
        }
        return [
            isTopLayer,
            x,
            y
        ];
    }
    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
        var elements = _ref.elements, rect = _ref.rect, offsetParent = _ref.offsetParent, strategy = _ref.strategy;
        var documentElement = getDocumentElement(offsetParent);
        var _$_ref = _sliced_to_array._(elements ? topLayer(elements.floating) : [
            false
        ], 1), isTopLayer = _$_ref[0];
        if (offsetParent === documentElement || isTopLayer) {
            return rect;
        }
        var scroll = {
            scrollLeft: 0,
            scrollTop: 0
        };
        var scale = createCoords(1);
        var offsets = createCoords(0);
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
            if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
                scroll = getNodeScroll(offsetParent);
            }
            if (isHTMLElement(offsetParent)) {
                var offsetRect = getBoundingClientRect(offsetParent);
                scale = getScale(offsetParent);
                offsets.x = offsetRect.x + offsetParent.clientLeft;
                offsets.y = offsetRect.y + offsetParent.clientTop;
            }
        }
        return {
            width: rect.width * scale.x,
            height: rect.height * scale.y,
            x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
            y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
        };
    }
    function getClientRects(element) {
        return Array.from(element.getClientRects());
    }
    function getWindowScrollBarX(element) {
        // If <html> has a CSS width greater than the viewport, then this will be
        // incorrect for RTL.
        return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
    }
    // Gets the entire size of the scrollable document area, even extending outside
    // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
    function getDocumentRect(element) {
        var html = getDocumentElement(element);
        var scroll = getNodeScroll(element);
        var body = element.ownerDocument.body;
        var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
        var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
        var x = -scroll.scrollLeft + getWindowScrollBarX(element);
        var y = -scroll.scrollTop;
        if (getComputedStyle(body).direction === "rtl") {
            x += max(html.clientWidth, body.clientWidth) - width;
        }
        return {
            width: width,
            height: height,
            x: x,
            y: y
        };
    }
    function getViewportRect(element, strategy) {
        var win = getWindow(element);
        var html = getDocumentElement(element);
        var visualViewport = win.visualViewport;
        var width = html.clientWidth;
        var height = html.clientHeight;
        var x = 0;
        var y = 0;
        if (visualViewport) {
            width = visualViewport.width;
            height = visualViewport.height;
            var visualViewportBased = isWebKit();
            if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
                x = visualViewport.offsetLeft;
                y = visualViewport.offsetTop;
            }
        }
        return {
            width: width,
            height: height,
            x: x,
            y: y
        };
    }
    // Returns the inner client rect, subtracting scrollbars if present.
    function getInnerBoundingClientRect(element, strategy) {
        var clientRect = getBoundingClientRect(element, true, strategy === "fixed");
        var top = clientRect.top + element.clientTop;
        var left = clientRect.left + element.clientLeft;
        var scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
        var width = element.clientWidth * scale.x;
        var height = element.clientHeight * scale.y;
        var x = left * scale.x;
        var y = top * scale.y;
        return {
            width: width,
            height: height,
            x: x,
            y: y
        };
    }
    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
        var rect;
        if (clippingAncestor === "viewport") {
            rect = getViewportRect(element, strategy);
        } else if (clippingAncestor === "document") {
            rect = getDocumentRect(getDocumentElement(element));
        } else if (isElement(clippingAncestor)) {
            rect = getInnerBoundingClientRect(clippingAncestor, strategy);
        } else {
            var visualOffsets = getVisualOffsets(element);
            rect = _object_spread_props._(_object_spread._({}, clippingAncestor), {
                x: clippingAncestor.x - visualOffsets.x,
                y: clippingAncestor.y - visualOffsets.y
            });
        }
        return core.rectToClientRect(rect);
    }
    function hasFixedPositionAncestor(element, stopNode) {
        var parentNode = getParentNode(element);
        if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
            return false;
        }
        return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
    }
    // A "clipping ancestor" is an `overflow` element with the characteristic of
    // clipping (or hiding) child elements. This returns all clipping ancestors
    // of the given element up the tree.
    function getClippingElementAncestors(element, cache) {
        var cachedResult = cache.get(element);
        if (cachedResult) {
            return cachedResult;
        }
        var result = getOverflowAncestors(element, [], false).filter(function(el) {
            return isElement(el) && getNodeName(el) !== "body";
        });
        var currentContainingBlockComputedStyle = null;
        var elementIsFixed = getComputedStyle(element).position === "fixed";
        var currentNode = elementIsFixed ? getParentNode(element) : element;
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        while(isElement(currentNode) && !isLastTraversableNode(currentNode)){
            var computedStyle = getComputedStyle(currentNode);
            var currentNodeIsContaining = isContainingBlock(currentNode);
            if (!currentNodeIsContaining && computedStyle.position === "fixed") {
                currentContainingBlockComputedStyle = null;
            }
            var shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && [
                "absolute",
                "fixed"
            ].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
            if (shouldDropCurrentNode) {
                // Drop non-containing blocks.
                result = result.filter(function(ancestor) {
                    return ancestor !== currentNode;
                });
            } else {
                // Record last containing block for next iteration.
                currentContainingBlockComputedStyle = computedStyle;
            }
            currentNode = getParentNode(currentNode);
        }
        cache.set(element, result);
        return result;
    }
    // Gets the maximum area that the element is visible in due to any number of
    // clipping ancestors.
    function getClippingRect(_ref) {
        var element = _ref.element, boundary = _ref.boundary, rootBoundary = _ref.rootBoundary, strategy = _ref.strategy;
        var elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
        var clippingAncestors = _to_consumable_array._(elementClippingAncestors).concat([
            rootBoundary
        ]);
        var firstClippingAncestor = clippingAncestors[0];
        var clippingRect = clippingAncestors.reduce(function(accRect, clippingAncestor) {
            var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
            accRect.top = max(rect.top, accRect.top);
            accRect.right = min(rect.right, accRect.right);
            accRect.bottom = min(rect.bottom, accRect.bottom);
            accRect.left = max(rect.left, accRect.left);
            return accRect;
        }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
        return {
            width: clippingRect.right - clippingRect.left,
            height: clippingRect.bottom - clippingRect.top,
            x: clippingRect.left,
            y: clippingRect.top
        };
    }
    function getDimensions(element) {
        var _getCssDimensions = getCssDimensions(element), width = _getCssDimensions.width, height = _getCssDimensions.height;
        return {
            width: width,
            height: height
        };
    }
    function getRectRelativeToOffsetParent(element, offsetParent, strategy, floating) {
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        var documentElement = getDocumentElement(offsetParent);
        var isFixed = strategy === "fixed";
        var rect = getBoundingClientRect(element, true, isFixed, offsetParent);
        var scroll = {
            scrollLeft: 0,
            scrollTop: 0
        };
        var offsets = createCoords(0);
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
                scroll = getNodeScroll(offsetParent);
            }
            if (isOffsetParentAnElement) {
                var offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
                offsets.x = offsetRect.x + offsetParent.clientLeft;
                offsets.y = offsetRect.y + offsetParent.clientTop;
            } else if (documentElement) {
                offsets.x = getWindowScrollBarX(documentElement);
            }
        }
        var x = rect.left + scroll.scrollLeft - offsets.x;
        var y = rect.top + scroll.scrollTop - offsets.y;
        var _topLayer = _sliced_to_array._(topLayer(floating), 3), isTopLayer = _topLayer[0], topLayerX = _topLayer[1], topLayerY = _topLayer[2];
        if (isTopLayer) {
            x += topLayerX;
            y += topLayerY;
            if (isOffsetParentAnElement) {
                x += offsetParent.clientLeft;
                y += offsetParent.clientTop;
            }
        }
        return {
            x: x,
            y: y,
            width: rect.width,
            height: rect.height
        };
    }
    function getTrueOffsetParent(element, polyfill) {
        if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
            return null;
        }
        if (polyfill) {
            return polyfill(element);
        }
        return element.offsetParent;
    }
    // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.
    function getOffsetParent(element, polyfill) {
        var window1 = getWindow(element);
        if (!isHTMLElement(element)) {
            return window1;
        }
        var offsetParent = getTrueOffsetParent(element, polyfill);
        while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static"){
            offsetParent = getTrueOffsetParent(offsetParent, polyfill);
        }
        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
            return window1;
        }
        return offsetParent || getContainingBlock(element) || window1;
    }
    var getElementRects = function() {
        var _ref = _async_to_generator._(function(data) {
            var getOffsetParentFn, getDimensionsFn, _tmp, _tmp1, _tmp2;
            return _ts_generator._(this, function(_state) {
                switch(_state.label){
                    case 0:
                        getOffsetParentFn = this.getOffsetParent || getOffsetParent;
                        getDimensionsFn = this.getDimensions;
                        _tmp = {};
                        _tmp1 = [
                            data.reference
                        ];
                        return [
                            4,
                            getOffsetParentFn(data.floating)
                        ];
                    case 1:
                        _tmp.reference = getRectRelativeToOffsetParent.apply(void 0, _tmp1.concat([
                            _state.sent(),
                            data.strategy,
                            data.floating
                        ]));
                        _tmp2 = [
                            {
                                x: 0,
                                y: 0
                            }
                        ];
                        return [
                            4,
                            getDimensionsFn(data.floating)
                        ];
                    case 2:
                        return [
                            2,
                            (_tmp.floating = _object_spread._.apply(void 0, _tmp2.concat([
                                _state.sent()
                            ])), _tmp)
                        ];
                }
            });
        });
        return function getElementRects(data) {
            return _ref.apply(this, arguments);
        };
    }();
    function isRTL(element) {
        return getComputedStyle(element).direction === "rtl";
    }
    var platform = {
        convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,
        getDocumentElement: getDocumentElement,
        getClippingRect: getClippingRect,
        getOffsetParent: getOffsetParent,
        getElementRects: getElementRects,
        getClientRects: getClientRects,
        getDimensions: getDimensions,
        getScale: getScale,
        isElement: isElement,
        isRTL: isRTL
    };
    // https://samthor.au/2021/observing-dom/
    function observeMove(element, onMove) {
        var io = null;
        var timeoutId;
        var root = getDocumentElement(element);
        function cleanup() {
            var _io;
            clearTimeout(timeoutId);
            (_io = io) == null || _io.disconnect();
            io = null;
        }
        function refresh(skip, threshold) {
            if (skip === void 0) {
                skip = false;
            }
            if (threshold === void 0) {
                threshold = 1;
            }
            cleanup();
            var _element_getBoundingClientRect = element.getBoundingClientRect(), left = _element_getBoundingClientRect.left, top = _element_getBoundingClientRect.top, width = _element_getBoundingClientRect.width, height = _element_getBoundingClientRect.height;
            if (!skip) {
                onMove();
            }
            if (!width || !height) {
                return;
            }
            var insetTop = floor(top);
            var insetRight = floor(root.clientWidth - (left + width));
            var insetBottom = floor(root.clientHeight - (top + height));
            var insetLeft = floor(left);
            var rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
            var options = {
                rootMargin: rootMargin,
                threshold: max(0, min(1, threshold)) || 1
            };
            var isFirstUpdate = true;
            function handleObserve(entries) {
                var ratio = entries[0].intersectionRatio;
                if (ratio !== threshold) {
                    if (!isFirstUpdate) {
                        return refresh();
                    }
                    if (!ratio) {
                        timeoutId = setTimeout(function() {
                            refresh(false, 1e-7);
                        }, 100);
                    } else {
                        refresh(false, ratio);
                    }
                }
                isFirstUpdate = false;
            }
            // Older browsers don't support a `document` as the root and will throw an
            // error.
            try {
                io = new IntersectionObserver(handleObserve, _object_spread_props._(_object_spread._({}, options), {
                    // Handle <iframe>s
                    root: root.ownerDocument
                }));
            } catch (e) {
                io = new IntersectionObserver(handleObserve, options);
            }
            io.observe(element);
        }
        refresh(true);
        return cleanup;
    }
    /**
   * Automatically updates the position of the floating element when necessary.
   * Should only be called when the floating element is mounted on the DOM or
   * visible on the screen.
   * @returns cleanup function that should be invoked when the floating element is
   * removed from the DOM or hidden from the screen.
   * @see https://floating-ui.com/docs/autoUpdate
   */ function autoUpdate(reference, floating, update, options) {
        if (options === void 0) {
            options = {};
        }
        var _options_ancestorScroll = options.ancestorScroll, ancestorScroll = _options_ancestorScroll === void 0 ? true : _options_ancestorScroll, _options_ancestorResize = options.ancestorResize, ancestorResize = _options_ancestorResize === void 0 ? true : _options_ancestorResize, _options_elementResize = options.elementResize, elementResize = _options_elementResize === void 0 ? typeof ResizeObserver === "function" : _options_elementResize, _options_layoutShift = options.layoutShift, layoutShift = _options_layoutShift === void 0 ? typeof IntersectionObserver === "function" : _options_layoutShift, _options_animationFrame = options.animationFrame, animationFrame = _options_animationFrame === void 0 ? false : _options_animationFrame;
        var referenceEl = unwrapElement(reference);
        var ancestors = ancestorScroll || ancestorResize ? _to_consumable_array._(referenceEl ? getOverflowAncestors(referenceEl) : []).concat(_to_consumable_array._(getOverflowAncestors(floating))) : [];
        ancestors.forEach(function(ancestor) {
            ancestorScroll && ancestor.addEventListener("scroll", update, {
                passive: true
            });
            ancestorResize && ancestor.addEventListener("resize", update);
        });
        var cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
        var reobserveFrame = -1;
        var resizeObserver = null;
        if (elementResize) {
            resizeObserver = new ResizeObserver(function(_ref) {
                var _$_ref = _sliced_to_array._(_ref, 1), firstEntry = _$_ref[0];
                if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                    // Prevent update loops when using the `size` middleware.
                    // https://github.com/floating-ui/floating-ui/issues/1740
                    resizeObserver.unobserve(floating);
                    cancelAnimationFrame(reobserveFrame);
                    reobserveFrame = requestAnimationFrame(function() {
                        var _resizeObserver;
                        (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                    });
                }
                update();
            });
            if (referenceEl && !animationFrame) {
                resizeObserver.observe(referenceEl);
            }
            resizeObserver.observe(floating);
        }
        var frameId;
        var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
        if (animationFrame) {
            frameLoop();
        }
        function frameLoop() {
            var nextRefRect = getBoundingClientRect(reference);
            if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
                update();
            }
            prevRefRect = nextRefRect;
            frameId = requestAnimationFrame(frameLoop);
        }
        update();
        return function() {
            var _resizeObserver2;
            ancestors.forEach(function(ancestor) {
                ancestorScroll && ancestor.removeEventListener("scroll", update);
                ancestorResize && ancestor.removeEventListener("resize", update);
            });
            cleanupIo == null || cleanupIo();
            (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
            resizeObserver = null;
            if (animationFrame) {
                cancelAnimationFrame(frameId);
            }
        };
    }
    /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */ var autoPlacement = core.autoPlacement;
    /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */ var shift = core.shift;
    /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */ var flip = core.flip;
    /**
   * Provides data that allows you to change the size of the floating element —
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */ var size = core.size;
    /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */ var hide = core.hide;
    /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * @see https://floating-ui.com/docs/arrow
   */ var arrow = core.arrow;
    /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */ var inline = core.inline;
    /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */ var limitShift = core.limitShift;
    /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a given reference element.
   */ var computePosition = function(reference, floating, options) {
        // This caches the expensive `getClippingElementAncestors` function so that
        // multiple lifecycle resets re-use the same result. It only lives for a
        // single call. If other functions become expensive, we can add them as well.
        var cache = new Map();
        var mergedOptions = _object_spread._({
            platform: platform
        }, options);
        var platformWithCache = _object_spread_props._(_object_spread._({}, mergedOptions.platform), {
            _c: cache
        });
        return core.computePosition(reference, floating, _object_spread_props._(_object_spread._({}, mergedOptions), {
            platform: platformWithCache
        }));
    };
    Object.defineProperty(exports1, "detectOverflow", {
        enumerable: true,
        get: function get() {
            return core.detectOverflow;
        }
    });
    Object.defineProperty(exports1, "offset", {
        enumerable: true,
        get: function get() {
            return core.offset;
        }
    });
    exports1.arrow = arrow;
    exports1.autoPlacement = autoPlacement;
    exports1.autoUpdate = autoUpdate;
    exports1.computePosition = computePosition;
    exports1.flip = flip;
    exports1.getOverflowAncestors = getOverflowAncestors;
    exports1.hide = hide;
    exports1.inline = inline;
    exports1.limitShift = limitShift;
    exports1.platform = platform;
    exports1.shift = shift;
    exports1.size = size;
});
