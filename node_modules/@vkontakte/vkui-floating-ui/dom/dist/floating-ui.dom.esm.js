import { _ as _async_to_generator } from "@swc/helpers/_/_async_to_generator";
import { _ as _object_spread } from "@swc/helpers/_/_object_spread";
import { _ as _object_spread_props } from "@swc/helpers/_/_object_spread_props";
import { _ as _sliced_to_array } from "@swc/helpers/_/_sliced_to_array";
import { _ as _to_consumable_array } from "@swc/helpers/_/_to_consumable_array";
import { _ as _ts_generator } from "@swc/helpers/_/_ts_generator";
import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '../../core/dist/floating-ui.core.esm.js';
export { detectOverflow, offset } from '../../core/dist/floating-ui.core.esm.js';
import { round, createCoords, max, min, floor } from '../../utils/dist/floating-ui.utils.esm.js';
import { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getContainingBlock, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement } from '../../utils/dom/floating-ui.utils.dom.esm.js';
export { getOverflowAncestors } from '../../utils/dom/floating-ui.utils.dom.esm.js';
function getCssDimensions(element) {
    var css = getComputedStyle(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    var width = parseFloat(css.width) || 0;
    var height = parseFloat(css.height) || 0;
    var hasOffset = isHTMLElement(element);
    var offsetWidth = hasOffset ? element.offsetWidth : width;
    var offsetHeight = hasOffset ? element.offsetHeight : height;
    var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
    }
    return {
        width: width,
        height: height,
        $: shouldFallback
    };
}
function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
    var domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
        return createCoords(1);
    }
    var rect = domElement.getBoundingClientRect();
    var _getCssDimensions = getCssDimensions(domElement), width = _getCssDimensions.width, height = _getCssDimensions.height, $ = _getCssDimensions.$;
    var x = ($ ? round(rect.width) : rect.width) / width;
    var y = ($ ? round(rect.height) : rect.height) / height;
    // 0, NaN, or Infinity should always fallback to 1.
    if (!x || !Number.isFinite(x)) {
        x = 1;
    }
    if (!y || !Number.isFinite(y)) {
        y = 1;
    }
    return {
        x: x,
        y: y
    };
}
var noOffsets = /*#__PURE__*/ createCoords(0);
function getVisualOffsets(element) {
    var win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
        return noOffsets;
    }
    return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
    };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
        isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
        return false;
    }
    return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
        includeScale = false;
    }
    if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var domElement = unwrapElement(element);
    var scale = createCoords(1);
    if (includeScale) {
        if (offsetParent) {
            if (isElement(offsetParent)) {
                scale = getScale(offsetParent);
            }
        } else {
            scale = getScale(element);
        }
    }
    var visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    var x = (clientRect.left + visualOffsets.x) / scale.x;
    var y = (clientRect.top + visualOffsets.y) / scale.y;
    var width = clientRect.width / scale.x;
    var height = clientRect.height / scale.y;
    if (domElement) {
        var win = getWindow(domElement);
        var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
        var currentIFrame = win.frameElement;
        while(currentIFrame && offsetParent && offsetWin !== win){
            var iframeScale = getScale(currentIFrame);
            var iframeRect = currentIFrame.getBoundingClientRect();
            var css = getComputedStyle(currentIFrame);
            var left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
            var top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
            x *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x += left;
            y += top;
            currentIFrame = getWindow(currentIFrame).frameElement;
        }
    }
    return rectToClientRect({
        width: width,
        height: height,
        x: x,
        y: y
    });
}
var topLayerSelectors = [
    ":popover-open",
    ":modal"
];
function topLayer(floating) {
    var isTopLayer = false;
    var x = 0;
    var y = 0;
    function setIsTopLayer(selector) {
        try {
            isTopLayer = isTopLayer || floating.matches(selector);
        } catch (e) {}
    }
    topLayerSelectors.forEach(function(selector) {
        setIsTopLayer(selector);
    });
    if (isTopLayer) {
        var containingBlock = getContainingBlock(floating);
        if (containingBlock) {
            var rect = containingBlock.getBoundingClientRect();
            x = rect.x;
            y = rect.y;
        }
    }
    return [
        isTopLayer,
        x,
        y
    ];
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    var elements = _ref.elements, rect = _ref.rect, offsetParent = _ref.offsetParent, strategy = _ref.strategy;
    var documentElement = getDocumentElement(offsetParent);
    var _$_ref = _sliced_to_array(elements ? topLayer(elements.floating) : [
        false
    ], 1), isTopLayer = _$_ref[0];
    if (offsetParent === documentElement || isTopLayer) {
        return rect;
    }
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var scale = createCoords(1);
    var offsets = createCoords(0);
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
        if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
            var offsetRect = getBoundingClientRect(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        }
    }
    return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
}
function getClientRects(element) {
    return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
    var html = getDocumentElement(element);
    var scroll = getNodeScroll(element);
    var body = element.ownerDocument.body;
    var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    var x = -scroll.scrollLeft + getWindowScrollBarX(element);
    var y = -scroll.scrollTop;
    if (getComputedStyle(body).direction === "rtl") {
        x += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}
function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var visualViewportBased = isWebKit();
        if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
    var clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    var top = clientRect.top + element.clientTop;
    var left = clientRect.left + element.clientLeft;
    var scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    var width = element.clientWidth * scale.x;
    var height = element.clientHeight * scale.y;
    var x = left * scale.x;
    var y = top * scale.y;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    var rect;
    if (clippingAncestor === "viewport") {
        rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
        rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
        rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
        var visualOffsets = getVisualOffsets(element);
        rect = _object_spread_props(_object_spread({}, clippingAncestor), {
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y
        });
    }
    return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
    var parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
        return false;
    }
    return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
    var cachedResult = cache.get(element);
    if (cachedResult) {
        return cachedResult;
    }
    var result = getOverflowAncestors(element, [], false).filter(function(el) {
        return isElement(el) && getNodeName(el) !== "body";
    });
    var currentContainingBlockComputedStyle = null;
    var elementIsFixed = getComputedStyle(element).position === "fixed";
    var currentNode = elementIsFixed ? getParentNode(element) : element;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while(isElement(currentNode) && !isLastTraversableNode(currentNode)){
        var computedStyle = getComputedStyle(currentNode);
        var currentNodeIsContaining = isContainingBlock(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === "fixed") {
            currentContainingBlockComputedStyle = null;
        }
        var shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && [
            "absolute",
            "fixed"
        ].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) {
            // Drop non-containing blocks.
            result = result.filter(function(ancestor) {
                return ancestor !== currentNode;
            });
        } else {
            // Record last containing block for next iteration.
            currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
}
// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
    var element = _ref.element, boundary = _ref.boundary, rootBoundary = _ref.rootBoundary, strategy = _ref.strategy;
    var elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
    var clippingAncestors = _to_consumable_array(elementClippingAncestors).concat([
        rootBoundary
    ]);
    var firstClippingAncestor = clippingAncestors[0];
    var clippingRect = clippingAncestors.reduce(function(accRect, clippingAncestor) {
        var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
    };
}
function getDimensions(element) {
    var _getCssDimensions = getCssDimensions(element), width = _getCssDimensions.width, height = _getCssDimensions.height;
    return {
        width: width,
        height: height
    };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy, floating) {
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var isFixed = strategy === "fixed";
    var rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
        }
        if (isOffsetParentAnElement) {
            var offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
        }
    }
    var x = rect.left + scroll.scrollLeft - offsets.x;
    var y = rect.top + scroll.scrollTop - offsets.y;
    var _topLayer = _sliced_to_array(topLayer(floating), 3), isTopLayer = _topLayer[0], topLayerX = _topLayer[1], topLayerY = _topLayer[2];
    if (isTopLayer) {
        x += topLayerX;
        y += topLayerY;
        if (isOffsetParentAnElement) {
            x += offsetParent.clientLeft;
            y += offsetParent.clientTop;
        }
    }
    return {
        x: x,
        y: y,
        width: rect.width,
        height: rect.height
    };
}
function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
        return null;
    }
    if (polyfill) {
        return polyfill(element);
    }
    return element.offsetParent;
}
// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
    var window = getWindow(element);
    if (!isHTMLElement(element)) {
        return window;
    }
    var offsetParent = getTrueOffsetParent(element, polyfill);
    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static"){
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
        return window;
    }
    return offsetParent || getContainingBlock(element) || window;
}
var getElementRects = function() {
    var _ref = _async_to_generator(function(data) {
        var getOffsetParentFn, getDimensionsFn, _tmp, _tmp1, _tmp2;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    getOffsetParentFn = this.getOffsetParent || getOffsetParent;
                    getDimensionsFn = this.getDimensions;
                    _tmp = {};
                    _tmp1 = [
                        data.reference
                    ];
                    return [
                        4,
                        getOffsetParentFn(data.floating)
                    ];
                case 1:
                    _tmp.reference = getRectRelativeToOffsetParent.apply(void 0, _tmp1.concat([
                        _state.sent(),
                        data.strategy,
                        data.floating
                    ]));
                    _tmp2 = [
                        {
                            x: 0,
                            y: 0
                        }
                    ];
                    return [
                        4,
                        getDimensionsFn(data.floating)
                    ];
                case 2:
                    return [
                        2,
                        (_tmp.floating = _object_spread.apply(void 0, _tmp2.concat([
                            _state.sent()
                        ])), _tmp)
                    ];
            }
        });
    });
    return function getElementRects(data) {
        return _ref.apply(this, arguments);
    };
}();
function isRTL(element) {
    return getComputedStyle(element).direction === "rtl";
}
var platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: getDocumentElement,
    getClippingRect: getClippingRect,
    getOffsetParent: getOffsetParent,
    getElementRects: getElementRects,
    getClientRects: getClientRects,
    getDimensions: getDimensions,
    getScale: getScale,
    isElement: isElement,
    isRTL: isRTL
};
// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
    var io = null;
    var timeoutId;
    var root = getDocumentElement(element);
    function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        (_io = io) == null || _io.disconnect();
        io = null;
    }
    function refresh(skip, threshold) {
        if (skip === void 0) {
            skip = false;
        }
        if (threshold === void 0) {
            threshold = 1;
        }
        cleanup();
        var _element_getBoundingClientRect = element.getBoundingClientRect(), left = _element_getBoundingClientRect.left, top = _element_getBoundingClientRect.top, width = _element_getBoundingClientRect.width, height = _element_getBoundingClientRect.height;
        if (!skip) {
            onMove();
        }
        if (!width || !height) {
            return;
        }
        var insetTop = floor(top);
        var insetRight = floor(root.clientWidth - (left + width));
        var insetBottom = floor(root.clientHeight - (top + height));
        var insetLeft = floor(left);
        var rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        var options = {
            rootMargin: rootMargin,
            threshold: max(0, min(1, threshold)) || 1
        };
        var isFirstUpdate = true;
        function handleObserve(entries) {
            var ratio = entries[0].intersectionRatio;
            if (ratio !== threshold) {
                if (!isFirstUpdate) {
                    return refresh();
                }
                if (!ratio) {
                    timeoutId = setTimeout(function() {
                        refresh(false, 1e-7);
                    }, 100);
                } else {
                    refresh(false, ratio);
                }
            }
            isFirstUpdate = false;
        }
        // Older browsers don't support a `document` as the root and will throw an
        // error.
        try {
            io = new IntersectionObserver(handleObserve, _object_spread_props(_object_spread({}, options), {
                // Handle <iframe>s
                root: root.ownerDocument
            }));
        } catch (e) {
            io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element);
    }
    refresh(true);
    return cleanup;
}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */ function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
        options = {};
    }
    var _options_ancestorScroll = options.ancestorScroll, ancestorScroll = _options_ancestorScroll === void 0 ? true : _options_ancestorScroll, _options_ancestorResize = options.ancestorResize, ancestorResize = _options_ancestorResize === void 0 ? true : _options_ancestorResize, _options_elementResize = options.elementResize, elementResize = _options_elementResize === void 0 ? typeof ResizeObserver === "function" : _options_elementResize, _options_layoutShift = options.layoutShift, layoutShift = _options_layoutShift === void 0 ? typeof IntersectionObserver === "function" : _options_layoutShift, _options_animationFrame = options.animationFrame, animationFrame = _options_animationFrame === void 0 ? false : _options_animationFrame;
    var referenceEl = unwrapElement(reference);
    var ancestors = ancestorScroll || ancestorResize ? _to_consumable_array(referenceEl ? getOverflowAncestors(referenceEl) : []).concat(_to_consumable_array(getOverflowAncestors(floating))) : [];
    ancestors.forEach(function(ancestor) {
        ancestorScroll && ancestor.addEventListener("scroll", update, {
            passive: true
        });
        ancestorResize && ancestor.addEventListener("resize", update);
    });
    var cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    var reobserveFrame = -1;
    var resizeObserver = null;
    if (elementResize) {
        resizeObserver = new ResizeObserver(function(_ref) {
            var _$_ref = _sliced_to_array(_ref, 1), firstEntry = _$_ref[0];
            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                // Prevent update loops when using the `size` middleware.
                // https://github.com/floating-ui/floating-ui/issues/1740
                resizeObserver.unobserve(floating);
                cancelAnimationFrame(reobserveFrame);
                reobserveFrame = requestAnimationFrame(function() {
                    var _resizeObserver;
                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                });
            }
            update();
        });
        if (referenceEl && !animationFrame) {
            resizeObserver.observe(referenceEl);
        }
        resizeObserver.observe(floating);
    }
    var frameId;
    var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
        frameLoop();
    }
    function frameLoop() {
        var nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
            update();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return function() {
        var _resizeObserver2;
        ancestors.forEach(function(ancestor) {
            ancestorScroll && ancestor.removeEventListener("scroll", update);
            ancestorResize && ancestor.removeEventListener("resize", update);
        });
        cleanupIo == null || cleanupIo();
        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
        resizeObserver = null;
        if (animationFrame) {
            cancelAnimationFrame(frameId);
        }
    };
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ var autoPlacement = autoPlacement$1;
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ var shift = shift$1;
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ var flip = flip$1;
/**
 * Provides data that allows you to change the size of the floating element â€”
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ var size = size$1;
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ var hide = hide$1;
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ var arrow = arrow$1;
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ var inline = inline$1;
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ var limitShift = limitShift$1;
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */ var computePosition = function(reference, floating, options) {
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    var cache = new Map();
    var mergedOptions = _object_spread({
        platform: platform
    }, options);
    var platformWithCache = _object_spread_props(_object_spread({}, mergedOptions.platform), {
        _c: cache
    });
    return computePosition$1(reference, floating, _object_spread_props(_object_spread({}, mergedOptions), {
        platform: platformWithCache
    }));
};
export { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };
