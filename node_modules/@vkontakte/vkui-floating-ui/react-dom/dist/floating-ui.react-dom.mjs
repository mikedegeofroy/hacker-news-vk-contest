import { _ as _object_spread } from "@swc/helpers/_/_object_spread";
import { _ as _object_spread_props } from "@swc/helpers/_/_object_spread_props";
import { _ as _sliced_to_array } from "@swc/helpers/_/_sliced_to_array";
import { _ as _type_of } from "@swc/helpers/_/_type_of";
import { arrow as arrow$1, computePosition } from '../../dom/dist/floating-ui.dom.mjs';
export { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '../../dom/dist/floating-ui.dom.mjs';
import * as React from "react";
import { useLayoutEffect, useEffect } from "react";
import * as ReactDOM from "react-dom";
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */ var arrow = function(options) {
    var isRef = function isRef(value) {
        return ({}).hasOwnProperty.call(value, "current");
    };
    return {
        name: "arrow",
        options: options,
        fn: function fn(state) {
            var _ref = typeof options === "function" ? options(state) : options, element = _ref.element, padding = _ref.padding;
            if (element && isRef(element)) {
                if (element.current != null) {
                    return arrow$1({
                        element: element.current,
                        padding: padding
                    }).fn(state);
                }
                return {};
            }
            if (element) {
                return arrow$1({
                    element: element,
                    padding: padding
                }).fn(state);
            }
            return {};
        }
    };
};
var index = typeof document !== "undefined" ? useLayoutEffect : useEffect;
// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    if ((typeof a === "undefined" ? "undefined" : _type_of(a)) !== (typeof b === "undefined" ? "undefined" : _type_of(b))) {
        return false;
    }
    if (typeof a === "function" && a.toString() === b.toString()) {
        return true;
    }
    var length;
    var i;
    var keys;
    if (a && b && typeof a === "object") {
        if (Array.isArray(a)) {
            length = a.length;
            if (length !== b.length) return false;
            for(i = length; i-- !== 0;){
                if (!deepEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) {
            return false;
        }
        for(i = length; i-- !== 0;){
            if (!({}).hasOwnProperty.call(b, keys[i])) {
                return false;
            }
        }
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (key === "_owner" && a.$$typeof) {
                continue;
            }
            if (!deepEqual(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    // biome-ignore lint/suspicious/noSelfCompare: in source
    return a !== a && b !== b;
}
function getDPR(element) {
    if (typeof window === "undefined") {
        return 1;
    }
    var win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
    var dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
    var ref = React.useRef(value);
    index(function() {
        ref.current = value;
    });
    return ref;
}
/**
 * Provides data to position a floating element.
 * @see https://floating-ui.com/docs/useFloating
 */ function useFloating(options) {
    if (options === void 0) {
        options = {};
    }
    var _options_placement = options.placement, placement = _options_placement === void 0 ? "bottom" : _options_placement, _options_strategy = options.strategy, strategy = _options_strategy === void 0 ? "absolute" : _options_strategy, _options_middleware = options.middleware, middleware = _options_middleware === void 0 ? [] : _options_middleware, platform = options.platform, tmp = options.elements, _ref = tmp === void 0 ? {} : tmp, externalReference = _ref.reference, externalFloating = _ref.floating, _options_transform = options.transform, transform = _options_transform === void 0 ? true : _options_transform, whileElementsMounted = options.whileElementsMounted, open = options.open;
    var _React_useState = _sliced_to_array(React.useState({
        x: 0,
        y: 0,
        strategy: strategy,
        placement: placement,
        middlewareData: {},
        isPositioned: false
    }), 2), data = _React_useState[0], setData = _React_useState[1];
    var _React_useState1 = _sliced_to_array(React.useState(middleware), 2), latestMiddleware = _React_useState1[0], setLatestMiddleware = _React_useState1[1];
    if (!deepEqual(latestMiddleware, middleware)) {
        setLatestMiddleware(middleware);
    }
    var _React_useState2 = _sliced_to_array(React.useState(null), 2), _reference = _React_useState2[0], _setReference = _React_useState2[1];
    var _React_useState3 = _sliced_to_array(React.useState(null), 2), _floating = _React_useState3[0], _setFloating = _React_useState3[1];
    var setReference = React.useCallback(function(node) {
        if (node !== referenceRef.current) {
            referenceRef.current = node;
            _setReference(node);
        }
    }, []);
    var setFloating = React.useCallback(function(node) {
        if (node !== floatingRef.current) {
            floatingRef.current = node;
            _setFloating(node);
        }
    }, []);
    var referenceEl = externalReference || _reference;
    var floatingEl = externalFloating || _floating;
    var referenceRef = React.useRef(null);
    var floatingRef = React.useRef(null);
    var dataRef = React.useRef(data);
    var hasWhileElementsMounted = whileElementsMounted != null;
    var whileElementsMountedRef = useLatestRef(whileElementsMounted);
    var platformRef = useLatestRef(platform);
    var update = React.useCallback(function() {
        if (!referenceRef.current || !floatingRef.current) {
            return;
        }
        var config = {
            placement: placement,
            strategy: strategy,
            middleware: latestMiddleware
        };
        if (platformRef.current) {
            config.platform = platformRef.current;
        }
        computePosition(referenceRef.current, floatingRef.current, config).then(function(data) {
            var fullData = _object_spread_props(_object_spread({}, data), {
                isPositioned: true
            });
            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
                dataRef.current = fullData;
                ReactDOM.flushSync(function() {
                    setData(fullData);
                });
            }
        });
    }, [
        latestMiddleware,
        placement,
        strategy,
        platformRef
    ]);
    index(function() {
        if (open === false && dataRef.current.isPositioned) {
            dataRef.current.isPositioned = false;
            setData(function(data) {
                return _object_spread_props(_object_spread({}, data), {
                    isPositioned: false
                });
            });
        }
    }, [
        open
    ]);
    var isMountedRef = React.useRef(false);
    index(function() {
        isMountedRef.current = true;
        return function() {
            isMountedRef.current = false;
        };
    }, []);
    // biome-ignore lint/correctness/useExhaustiveDependencies: `hasWhileElementsMounted` is intentionally included.
    index(function() {
        if (referenceEl) referenceRef.current = referenceEl;
        if (floatingEl) floatingRef.current = floatingEl;
        if (referenceEl && floatingEl) {
            if (whileElementsMountedRef.current) {
                return whileElementsMountedRef.current(referenceEl, floatingEl, update);
            }
            update();
        }
    }, [
        referenceEl,
        floatingEl,
        update,
        whileElementsMountedRef,
        hasWhileElementsMounted
    ]);
    var refs = React.useMemo(function() {
        return {
            reference: referenceRef,
            floating: floatingRef,
            setReference: setReference,
            setFloating: setFloating
        };
    }, [
        setReference,
        setFloating
    ]);
    var elements = React.useMemo(function() {
        return {
            reference: referenceEl,
            floating: floatingEl
        };
    }, [
        referenceEl,
        floatingEl
    ]);
    var floatingStyles = React.useMemo(function() {
        var initialStyles = {
            position: strategy,
            left: 0,
            top: 0
        };
        if (!elements.floating) {
            return initialStyles;
        }
        var x = roundByDPR(elements.floating, data.x);
        var y = roundByDPR(elements.floating, data.y);
        if (transform) {
            return _object_spread(_object_spread_props(_object_spread({}, initialStyles), {
                transform: "translate(" + x + "px, " + y + "px)"
            }), getDPR(elements.floating) >= 1.5 && {
                willChange: "transform"
            });
        }
        return {
            position: strategy,
            left: x,
            top: y
        };
    }, [
        strategy,
        transform,
        elements.floating,
        data.x,
        data.y
    ]);
    return React.useMemo(function() {
        return _object_spread_props(_object_spread({}, data), {
            update: update,
            refs: refs,
            elements: elements,
            floatingStyles: floatingStyles
        });
    }, [
        data,
        update,
        refs,
        elements,
        floatingStyles
    ]);
}
export { arrow, useFloating };
