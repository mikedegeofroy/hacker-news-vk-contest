{"version":3,"sources":["../../../../src/components/BaseGallery/CarouselBase/helpers.ts"],"sourcesContent":["import { GallerySlidesState } from '../types';\nimport { SLIDE_THRESHOLD } from './constants';\nimport { LoopPoint, SlidesManagerState } from './types';\n\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent(\n  targetIndex: number,\n  slidesManager: SlidesManagerState,\n  isCenterWithCustomWidth: boolean,\n) {\n  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {\n    return 0;\n  }\n\n  const targetSlide = slidesManager.slides[targetIndex];\n\n  if (targetSlide) {\n    const { coordX, width } = targetSlide;\n\n    if (isCenterWithCustomWidth) {\n      return slidesManager.viewportOffsetWidth / 2 - coordX - width / 2;\n    }\n\n    return -1 * coordX;\n  }\n\n  return 0;\n}\n\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\nexport function getShiftedIndexes(\n  direction: 1 | -1,\n  slides: GallerySlidesState[],\n  availableWidth: number,\n) {\n  let gap = availableWidth;\n  const shiftedSlideIndexes = [];\n  const startIndex = direction === 1 ? 0 : slides.length - 1;\n  const endIndex = direction === 1 ? slides.length - 1 : 0;\n\n  for (\n    let i = startIndex;\n    (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0;\n    i += direction\n  ) {\n    const slideWidth = slides[i].width;\n\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n\n  return shiftedSlideIndexes;\n}\n\nexport function calculateLoopPoints(\n  indexes: number[],\n  edge: 'start' | 'end',\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n): LoopPoint[] {\n  const { contentSize, slides, snaps } = slidesManager;\n  const isStartEdge = edge === 'start';\n  const offset = isStartEdge ? -contentSize : contentSize;\n\n  return indexes.map((index) => {\n    const initial = isStartEdge ? 0 : -contentSize;\n    const altered = isStartEdge ? contentSize : 0;\n    const loopPoint = isStartEdge\n      ? snaps[index] + containerWidth + offset\n      : snaps[index] - slides[index].width + offset - snaps[0];\n\n    return {\n      index,\n      target: (currentLocation) => {\n        return currentLocation >= loopPoint ? initial : altered;\n      },\n    };\n  });\n}\n\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\nexport function getLoopPoints(slidesManager: SlidesManagerState, containerWidth: number) {\n  const { slides, snaps } = slidesManager;\n  const startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);\n  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);\n\n  return [\n    ...calculateLoopPoints(endShiftedIndexes, 'start', slidesManager, containerWidth),\n    ...calculateLoopPoints(startShiftedIndexes, 'end', slidesManager, containerWidth),\n  ];\n}\n\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex(\n  slides: GallerySlidesState[],\n  slideIndex: number,\n  currentShiftX: number,\n  currentShiftXDelta: number,\n) {\n  const shift = currentShiftX + currentShiftXDelta;\n  const direction = currentShiftXDelta < 0 ? 1 : -1;\n\n  // Находим ближайшую границу слайда к текущему отступу\n  let targetIndex = slides.reduce((val: number, item: GallerySlidesState, index: number) => {\n    const previousValue = Math.abs(slides[val].coordX + shift);\n    const currentValue = Math.abs(item.coordX + shift);\n\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n\n  if (targetIndex === slideIndex) {\n    let targetSlide = slideIndex + direction;\n\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    return direction < 0\n      ? (targetSlide + slides.length) % slides.length\n      : targetSlide % slides.length;\n  }\n\n  return targetIndex;\n}\n"],"names":["SLIDE_THRESHOLD","calculateIndent","targetIndex","slidesManager","isCenterWithCustomWidth","isFullyVisible","slides","length","targetSlide","coordX","width","viewportOffsetWidth","getShiftedIndexes","direction","availableWidth","gap","shiftedSlideIndexes","startIndex","endIndex","i","slideWidth","push","calculateLoopPoints","indexes","edge","containerWidth","contentSize","snaps","isStartEdge","offset","map","index","initial","altered","loopPoint","target","currentLocation","getLoopPoints","startShiftedIndexes","endShiftedIndexes","getTargetIndex","slideIndex","currentShiftX","currentShiftXDelta","shift","reduce","val","item","previousValue","Math","abs","currentValue"],"mappings":"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"}