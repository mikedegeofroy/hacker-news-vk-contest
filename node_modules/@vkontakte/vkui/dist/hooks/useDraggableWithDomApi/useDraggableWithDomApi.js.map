{"version":3,"sources":["../../../src/hooks/useDraggableWithDomApi/useDraggableWithDomApi.ts"],"sourcesContent":["import * as React from 'react';\nimport type { TouchEvent } from '../../components/Touch/Touch';\nimport { getBoundingClientRect, getNearestOverflowAncestor, getNodeScroll } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { createAutoScrollController, getAutoScrollingData } from './autoScroll';\nimport {\n  AUTO_SCROLL_START_DELAY,\n  DATA_DRAGGABLE_PLACEHOLDER_KEY,\n  ITEM_INITIAL_INDEX,\n} from './constants';\nimport type {\n  Direction,\n  DraggingItem,\n  PlaceholderItem,\n  SiblingItem,\n  UseDraggable,\n  UseDraggableProps,\n} from './types';\nimport {\n  getTargetIsOverOrUnderElData,\n  setDraggingItemShiftStyles,\n  setInitialDraggingItemStyles,\n  setInitialPlaceholderItemStyles,\n  setInitialSiblingItemStyles,\n  setSiblingItemsShiftStyles,\n  unsetInitialDraggingItemStyles,\n  unsetInitialPlaceholderItemStyles,\n  unsetInitialSiblingItemStyles,\n} from './utils';\n\nexport const useDraggableWithDomApi = <T extends HTMLElement>({\n  elRef: draggingElRef,\n  onDragFinish,\n}: UseDraggableProps<T>): UseDraggable => {\n  const [dragging, setDragging] = React.useState(false);\n  const lastClientYRef = React.useRef(0);\n  const lastDragShiftYRef = React.useRef(0);\n\n  const scrollElRef = React.useRef<Element | Window | null>(null);\n  const lastScrollTopRef = React.useRef<number>(0);\n  const scrollControllerRef = React.useRef<ReturnType<typeof createAutoScrollController> | null>(\n    null,\n  );\n  const initializeScrollRefs = (draggableEl: HTMLElement) => {\n    const node = getNearestOverflowAncestor(draggableEl);\n    if (node) {\n      scrollElRef.current = node;\n      lastScrollTopRef.current = getNodeScroll(node).scrollTop;\n      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);\n    }\n  };\n  const cleanupScrollRefs = () => {\n    lastScrollTopRef.current = 0;\n    scrollControllerRef.current?.stop();\n    scrollElRef.current = scrollControllerRef.current = null;\n  };\n\n  const lastDragDirectionRef = React.useRef<Direction | undefined>(undefined);\n  const toggleDragDirection = (prevShiftY: number, nextShiftY: number) => {\n    const shiftYDiff = prevShiftY - nextShiftY;\n    if (shiftYDiff < 0) {\n      return 'down';\n    }\n    if (shiftYDiff > 0) {\n      return 'up';\n    }\n    return lastDragDirectionRef.current;\n  };\n\n  const itemStartIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const itemEndIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const draggingItemRef = React.useRef<DraggingItem | null>(null);\n  const placeholderItemRef = React.useRef<PlaceholderItem | null>(null);\n  const siblingItemsRef = React.useRef<SiblingItem[]>([]);\n  const initializeItems = (draggingEl: HTMLElement) => {\n    const draggingElRect = getBoundingClientRect(draggingEl, true);\n    const { children } = draggingEl.parentElement || { children: [] };\n    Array.prototype.forEach.call(children, (el: HTMLElement, index) => {\n      if (el === draggingEl) {\n        itemStartIndexRef.current = itemEndIndexRef.current = index;\n        draggingItemRef.current = { index, el, draggingElRect };\n      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {\n        placeholderItemRef.current = { index, el, draggingElRect };\n      } else {\n        siblingItemsRef.current.push({ index, el, shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index, draggingElRect }); // prettier-ignore\n      }\n    });\n    if (placeholderItemRef.current) {\n      setInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      setInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(setInitialSiblingItemStyles); // 2. repaint\n  };\n  const cleanupItems = () => {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      unsetInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles); // 2. repaint\n    siblingItemsRef.current = [];\n    placeholderItemRef.current = draggingItemRef.current = null;\n\n    const swappedItemIndexRange = { from: itemStartIndexRef.current, to: itemEndIndexRef.current };\n    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;\n    return swappedItemIndexRange;\n  };\n  const getShiftAndUnshiftItemsPreparedData = (\n    clientY: number,\n  ): [Array<[SiblingItem, Direction]>, Array<[SiblingItem, Direction]>] => {\n    const shiftItemEls: Array<[SiblingItem, Direction]> = [];\n    const unshiftItemEls: Array<[SiblingItem, Direction]> = [];\n    itemEndIndexRef.current = itemStartIndexRef.current;\n    siblingItemsRef.current.forEach((siblingItem) => {\n      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(\n        clientY,\n        getBoundingClientRect(siblingItem.el),\n      );\n      if (itemStartIndexRef.current < siblingItem.index) {\n        if (isOverEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current + 1;\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            shiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n        if (isUnderEl) {\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            unshiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n      } else if (itemStartIndexRef.current > siblingItem.index) {\n        if (isUnderEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current - 1;\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            shiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n        if (isOverEl) {\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            unshiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n      }\n    });\n    return [shiftItemEls, unshiftItemEls];\n  };\n  const setShiftAndUnshiftItemStyles = (\n    shiftItemEls: Array<[SiblingItem, Direction]>,\n    unshiftItemEls: Array<[SiblingItem, Direction]>,\n  ) => {\n    shiftItemEls.forEach(setSiblingItemsShiftStyles);\n    unshiftItemEls.forEach(setSiblingItemsShiftStyles);\n  };\n\n  const schedulingAutoScrollTimeoutIdRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n  const clearSchedulingAutoScrollTimeout = () => {\n    if (schedulingAutoScrollTimeoutIdRef.current) {\n      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);\n      schedulingAutoScrollTimeoutIdRef.current = null;\n    }\n  };\n  const tryAutoScroll = () => {\n    if (scrollControllerRef.current) {\n      scrollControllerRef.current.tryAutoScroll(() => {\n        return scrollElRef.current\n          ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current)\n          : {\n              shouldScrolling: false,\n              y: 0,\n            };\n      });\n    }\n  };\n  const schedulingAutoScroll = () => {\n    clearSchedulingAutoScrollTimeout();\n    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {\n      schedulingAutoScrollTimeoutIdRef.current = null;\n      tryAutoScroll();\n    }, AUTO_SCROLL_START_DELAY);\n  };\n\n  const onDragStart = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const onDragMove = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    const draggingEl = draggingElRef.current;\n\n    if (!draggingEl) {\n      return;\n    }\n\n    if (dragging) {\n      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);\n      lastDragShiftYRef.current = event.shiftY;\n      lastClientYRef.current = event.clientY;\n\n      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n      } else {\n        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(\n          lastClientYRef.current,\n        );\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n        schedulingAutoScroll();\n      }\n    } else {\n      setDragging((prevDragging) => {\n        // На случай, если onDragMove успеет вызваться ещё раз до того, как `dragging` выставится в\n        // `true`\n        if (prevDragging) {\n          return prevDragging;\n        }\n        initializeScrollRefs(draggingEl);\n        initializeItems(draggingEl);\n        return true;\n      });\n    }\n  };\n\n  const onDragEnd = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    clearSchedulingAutoScrollTimeout();\n    cleanupScrollRefs();\n\n    lastClientYRef.current = lastDragShiftYRef.current = 0;\n    lastDragDirectionRef.current = undefined;\n\n    if (dragging) {\n      const swappedItemRange = cleanupItems();\n      if (onDragFinish) {\n        onDragFinish(swappedItemRange);\n      }\n      setDragging(false);\n    }\n  };\n\n  const handleScroll = React.useCallback(() => {\n    if (!draggingElRef.current || !scrollElRef.current) {\n      return;\n    }\n\n    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;\n    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);\n    const scrollDiff = lastScrollTopRef.current - nextScrollTop;\n    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;\n    lastScrollTopRef.current = nextScrollTop;\n\n    const [shiftItemEls, unshiftItemEls] =\n      getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);\n    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n  }, [draggingElRef]);\n\n  useIsomorphicLayoutEffect(\n    function recalculateOnScroll() {\n      const scrollEl = scrollElRef.current;\n      if (!dragging || !scrollEl) {\n        return;\n      }\n      scrollEl.addEventListener('scroll', handleScroll);\n      return () => {\n        if (scrollEl) {\n          scrollEl.removeEventListener('scroll', handleScroll);\n        }\n      };\n    },\n    [dragging, handleScroll],\n  );\n\n  useIsomorphicLayoutEffect(\n    () =>\n      function componentWillUnmount() {\n        if (placeholderItemRef.current) {\n          unsetInitialPlaceholderItemStyles(placeholderItemRef.current);\n        }\n      },\n    [],\n  );\n\n  return { dragging, onDragStart, onDragMove, onDragEnd };\n};\n"],"names":["React","getBoundingClientRect","getNearestOverflowAncestor","getNodeScroll","useIsomorphicLayoutEffect","createAutoScrollController","getAutoScrollingData","AUTO_SCROLL_START_DELAY","DATA_DRAGGABLE_PLACEHOLDER_KEY","ITEM_INITIAL_INDEX","getTargetIsOverOrUnderElData","setDraggingItemShiftStyles","setInitialDraggingItemStyles","setInitialPlaceholderItemStyles","setInitialSiblingItemStyles","setSiblingItemsShiftStyles","unsetInitialDraggingItemStyles","unsetInitialPlaceholderItemStyles","unsetInitialSiblingItemStyles","useDraggableWithDomApi","elRef","draggingElRef","onDragFinish","dragging","setDragging","useState","lastClientYRef","useRef","lastDragShiftYRef","scrollElRef","lastScrollTopRef","scrollControllerRef","initializeScrollRefs","draggableEl","node","current","scrollTop","cleanupScrollRefs","stop","lastDragDirectionRef","undefined","toggleDragDirection","prevShiftY","nextShiftY","shiftYDiff","itemStartIndexRef","itemEndIndexRef","draggingItemRef","placeholderItemRef","siblingItemsRef","initializeItems","draggingEl","draggingElRect","children","parentElement","Array","prototype","forEach","call","el","index","getAttribute","push","shifted","cleanupItems","swappedItemIndexRange","from","to","getShiftAndUnshiftItemsPreparedData","clientY","shiftItemEls","unshiftItemEls","siblingItem","isOverEl","isUnderEl","setShiftAndUnshiftItemStyles","schedulingAutoScrollTimeoutIdRef","clearSchedulingAutoScrollTimeout","clearTimeout","tryAutoScroll","shouldScrolling","y","schedulingAutoScroll","setTimeout","onDragStart","event","originalEvent","stopPropagation","preventDefault","onDragMove","shiftY","isRunning","prevDragging","onDragEnd","swappedItemRange","handleScroll","useCallback","nextScrollTop","scrollDiff","clientYWithScrollOffset","recalculateOnScroll","scrollEl","addEventListener","removeEventListener","componentWillUnmount"],"mappings":"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"}