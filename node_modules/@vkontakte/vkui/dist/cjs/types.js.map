{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["import * as React from 'react';\nimport { PlatformType } from './lib/platform';\n\nexport type AnyFunction = (...args: any[]) => any;\n\nexport type AlignType = 'left' | 'center' | 'right';\n\nexport interface HasChildren {\n  children?: React.ReactNode;\n}\n\nexport type HasDataAttribute = Record<\n  `data-${string}`,\n  string | number | boolean | undefined | null\n>;\n\nexport interface HasRootRef<T> {\n  getRootRef?: React.Ref<T>;\n}\n\nexport interface HasRef<T> {\n  getRef?: React.Ref<T>;\n}\n\nexport interface HasComponent {\n  Component?: React.ElementType;\n}\n\nexport interface HasAlign {\n  align?: AlignType;\n}\n\nexport interface HasPlatform {\n  /**\n   * @ignore\n   */\n  platform?: PlatformType;\n}\n\nexport interface Version {\n  major: number;\n  minor?: number;\n  patch?: number;\n}\n\n/**\n * Тип содержит атрибуты, которые применяются только для `<a>`\n *\n * @see {@link https://developer.mozilla.org/ru/docs/Web/HTML/Element/A &lt;a&gt; - HTML | MDN}\n */\nexport type AnchorHTMLAttributesOnly = Omit<\n  React.AnchorHTMLAttributes<HTMLAnchorElement>,\n  keyof React.HTMLAttributes<HTMLAnchorElement>\n>;\n\n/**\n * Проверяет, является ли тип подтипом другого.\n *\n * В TS не реализовано.\n *\n * @see {@link https://github.com/microsoft/TypeScript/issues/12936}\n */\nexport type Exact<A, B> = A extends B ? B : never;\n\n/**\n * Для возможности указывать css custom properties\n */\nexport type CSSCustomProperties<T extends string | undefined = string> = Record<`--${string}`, T>;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface Nothing {}\n\n/**\n * Автозаполнение для типов\n *\n * @example\n * LiteralUnion<'foo' | 'bar', string>\n *\n * @see {@link https://github.com/microsoft/TypeScript/issues/29729}\n */\nexport type LiteralUnion<Union, Type> = Union | (Type & Nothing);\n\nexport type HTMLAttributesWithRootRef<T> = React.HTMLAttributes<T> & HasRootRef<T>;\n\nexport type ValuesOfObject<T> = T[keyof T];\n\nexport type GetPropsWithFunctionKeys<T> = {\n  [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never;\n}[keyof T];\n\nexport type PickOnlyFunctionProps<T> = Pick<T, GetPropsWithFunctionKeys<T>>;\n\n/**\n * Даёт возможность поймать ошибку, если в компонент передаются лишние свойства.\n *\n * @example\n * // пример использования\n * const nativeProps: HasOnlyExpectedProps<typeof restProps, NativeSelectProps> = restProps;\n *\n * @example\n * // расширенный пример\n * type SelectProps {\n *   mode: string,\n *   multiline: boolean;\n *   selectType?: SelectType;\n * }\n *\n * type NativeSelectProps {\n *   selectType?: SelectType;\n * }\n *\n * const selectProps: SelectProps = {\n *   mode: \"card\",\n *   multiline: true,\n *   selectType: \"default\",\n * }\n *\n * // будет ошибка, так как multiline в NativeSelectProps нет\n * const {mode, ...restProps} = selectProps;\n * const nativeProps: HasOnlyExpectedProps<typeof restProps, NativeSelectProps> = restProps;\n *\n * // а вот так ошибки не будет, так как restProps больше не содержит multiline\n * const {mode, multiline, ...restProps} = selectProps;\n * const nativeProps: HasOnlyExpectedProps<typeof restProps, NativeSelectProps> = restProps;\n */\nexport type HasOnlyExpectedProps<Props, ExpectedProps> = {\n  [K in keyof Props]: K extends keyof ExpectedProps ? ExpectedProps[K] : never;\n};\n"],"names":[],"mappings":";;;;;iEAAuB"}