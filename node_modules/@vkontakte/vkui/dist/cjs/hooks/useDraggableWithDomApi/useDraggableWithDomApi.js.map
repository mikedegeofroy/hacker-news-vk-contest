{"version":3,"sources":["../../../../src/hooks/useDraggableWithDomApi/useDraggableWithDomApi.ts"],"sourcesContent":["import * as React from 'react';\nimport type { TouchEvent } from '../../components/Touch/Touch';\nimport { getBoundingClientRect, getNearestOverflowAncestor, getNodeScroll } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { createAutoScrollController, getAutoScrollingData } from './autoScroll';\nimport {\n  AUTO_SCROLL_START_DELAY,\n  DATA_DRAGGABLE_PLACEHOLDER_KEY,\n  ITEM_INITIAL_INDEX,\n} from './constants';\nimport type {\n  Direction,\n  DraggingItem,\n  PlaceholderItem,\n  SiblingItem,\n  UseDraggable,\n  UseDraggableProps,\n} from './types';\nimport {\n  getTargetIsOverOrUnderElData,\n  setDraggingItemShiftStyles,\n  setInitialDraggingItemStyles,\n  setInitialPlaceholderItemStyles,\n  setInitialSiblingItemStyles,\n  setSiblingItemsShiftStyles,\n  unsetInitialDraggingItemStyles,\n  unsetInitialPlaceholderItemStyles,\n  unsetInitialSiblingItemStyles,\n} from './utils';\n\nexport const useDraggableWithDomApi = <T extends HTMLElement>({\n  elRef: draggingElRef,\n  onDragFinish,\n}: UseDraggableProps<T>): UseDraggable => {\n  const [dragging, setDragging] = React.useState(false);\n  const lastClientYRef = React.useRef(0);\n  const lastDragShiftYRef = React.useRef(0);\n\n  const scrollElRef = React.useRef<Element | Window | null>(null);\n  const lastScrollTopRef = React.useRef<number>(0);\n  const scrollControllerRef = React.useRef<ReturnType<typeof createAutoScrollController> | null>(\n    null,\n  );\n  const initializeScrollRefs = (draggableEl: HTMLElement) => {\n    const node = getNearestOverflowAncestor(draggableEl);\n    if (node) {\n      scrollElRef.current = node;\n      lastScrollTopRef.current = getNodeScroll(node).scrollTop;\n      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);\n    }\n  };\n  const cleanupScrollRefs = () => {\n    lastScrollTopRef.current = 0;\n    scrollControllerRef.current?.stop();\n    scrollElRef.current = scrollControllerRef.current = null;\n  };\n\n  const lastDragDirectionRef = React.useRef<Direction | undefined>(undefined);\n  const toggleDragDirection = (prevShiftY: number, nextShiftY: number) => {\n    const shiftYDiff = prevShiftY - nextShiftY;\n    if (shiftYDiff < 0) {\n      return 'down';\n    }\n    if (shiftYDiff > 0) {\n      return 'up';\n    }\n    return lastDragDirectionRef.current;\n  };\n\n  const itemStartIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const itemEndIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const draggingItemRef = React.useRef<DraggingItem | null>(null);\n  const placeholderItemRef = React.useRef<PlaceholderItem | null>(null);\n  const siblingItemsRef = React.useRef<SiblingItem[]>([]);\n  const initializeItems = (draggingEl: HTMLElement) => {\n    const draggingElRect = getBoundingClientRect(draggingEl, true);\n    const { children } = draggingEl.parentElement || { children: [] };\n    Array.prototype.forEach.call(children, (el: HTMLElement, index) => {\n      if (el === draggingEl) {\n        itemStartIndexRef.current = itemEndIndexRef.current = index;\n        draggingItemRef.current = { index, el, draggingElRect };\n      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {\n        placeholderItemRef.current = { index, el, draggingElRect };\n      } else {\n        siblingItemsRef.current.push({ index, el, shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index, draggingElRect }); // prettier-ignore\n      }\n    });\n    if (placeholderItemRef.current) {\n      setInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      setInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(setInitialSiblingItemStyles); // 2. repaint\n  };\n  const cleanupItems = () => {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      unsetInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles); // 2. repaint\n    siblingItemsRef.current = [];\n    placeholderItemRef.current = draggingItemRef.current = null;\n\n    const swappedItemIndexRange = { from: itemStartIndexRef.current, to: itemEndIndexRef.current };\n    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;\n    return swappedItemIndexRange;\n  };\n  const getShiftAndUnshiftItemsPreparedData = (\n    clientY: number,\n  ): [Array<[SiblingItem, Direction]>, Array<[SiblingItem, Direction]>] => {\n    const shiftItemEls: Array<[SiblingItem, Direction]> = [];\n    const unshiftItemEls: Array<[SiblingItem, Direction]> = [];\n    itemEndIndexRef.current = itemStartIndexRef.current;\n    siblingItemsRef.current.forEach((siblingItem) => {\n      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(\n        clientY,\n        getBoundingClientRect(siblingItem.el),\n      );\n      if (itemStartIndexRef.current < siblingItem.index) {\n        if (isOverEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current + 1;\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            shiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n        if (isUnderEl) {\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            unshiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n      } else if (itemStartIndexRef.current > siblingItem.index) {\n        if (isUnderEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current - 1;\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            shiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n        if (isOverEl) {\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            unshiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n      }\n    });\n    return [shiftItemEls, unshiftItemEls];\n  };\n  const setShiftAndUnshiftItemStyles = (\n    shiftItemEls: Array<[SiblingItem, Direction]>,\n    unshiftItemEls: Array<[SiblingItem, Direction]>,\n  ) => {\n    shiftItemEls.forEach(setSiblingItemsShiftStyles);\n    unshiftItemEls.forEach(setSiblingItemsShiftStyles);\n  };\n\n  const schedulingAutoScrollTimeoutIdRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n  const clearSchedulingAutoScrollTimeout = () => {\n    if (schedulingAutoScrollTimeoutIdRef.current) {\n      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);\n      schedulingAutoScrollTimeoutIdRef.current = null;\n    }\n  };\n  const tryAutoScroll = () => {\n    if (scrollControllerRef.current) {\n      scrollControllerRef.current.tryAutoScroll(() => {\n        return scrollElRef.current\n          ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current)\n          : {\n              shouldScrolling: false,\n              y: 0,\n            };\n      });\n    }\n  };\n  const schedulingAutoScroll = () => {\n    clearSchedulingAutoScrollTimeout();\n    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {\n      schedulingAutoScrollTimeoutIdRef.current = null;\n      tryAutoScroll();\n    }, AUTO_SCROLL_START_DELAY);\n  };\n\n  const onDragStart = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const onDragMove = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    const draggingEl = draggingElRef.current;\n\n    if (!draggingEl) {\n      return;\n    }\n\n    if (dragging) {\n      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);\n      lastDragShiftYRef.current = event.shiftY;\n      lastClientYRef.current = event.clientY;\n\n      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n      } else {\n        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(\n          lastClientYRef.current,\n        );\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n        schedulingAutoScroll();\n      }\n    } else {\n      setDragging((prevDragging) => {\n        // На случай, если onDragMove успеет вызваться ещё раз до того, как `dragging` выставится в\n        // `true`\n        if (prevDragging) {\n          return prevDragging;\n        }\n        initializeScrollRefs(draggingEl);\n        initializeItems(draggingEl);\n        return true;\n      });\n    }\n  };\n\n  const onDragEnd = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    clearSchedulingAutoScrollTimeout();\n    cleanupScrollRefs();\n\n    lastClientYRef.current = lastDragShiftYRef.current = 0;\n    lastDragDirectionRef.current = undefined;\n\n    if (dragging) {\n      const swappedItemRange = cleanupItems();\n      if (onDragFinish) {\n        onDragFinish(swappedItemRange);\n      }\n      setDragging(false);\n    }\n  };\n\n  const handleScroll = React.useCallback(() => {\n    if (!draggingElRef.current || !scrollElRef.current) {\n      return;\n    }\n\n    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;\n    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);\n    const scrollDiff = lastScrollTopRef.current - nextScrollTop;\n    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;\n    lastScrollTopRef.current = nextScrollTop;\n\n    const [shiftItemEls, unshiftItemEls] =\n      getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);\n    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n  }, [draggingElRef]);\n\n  useIsomorphicLayoutEffect(\n    function recalculateOnScroll() {\n      const scrollEl = scrollElRef.current;\n      if (!dragging || !scrollEl) {\n        return;\n      }\n      scrollEl.addEventListener('scroll', handleScroll);\n      return () => {\n        if (scrollEl) {\n          scrollEl.removeEventListener('scroll', handleScroll);\n        }\n      };\n    },\n    [dragging, handleScroll],\n  );\n\n  useIsomorphicLayoutEffect(\n    () =>\n      function componentWillUnmount() {\n        if (placeholderItemRef.current) {\n          unsetInitialPlaceholderItemStyles(placeholderItemRef.current);\n        }\n      },\n    [],\n  );\n\n  return { dragging, onDragStart, onDragMove, onDragEnd };\n};\n"],"names":["useDraggableWithDomApi","elRef","draggingElRef","onDragFinish","dragging","setDragging","React","useState","lastClientYRef","useRef","lastDragShiftYRef","scrollElRef","lastScrollTopRef","scrollControllerRef","initializeScrollRefs","draggableEl","node","getNearestOverflowAncestor","current","getNodeScroll","scrollTop","createAutoScrollController","cleanupScrollRefs","stop","lastDragDirectionRef","undefined","toggleDragDirection","prevShiftY","nextShiftY","shiftYDiff","itemStartIndexRef","ITEM_INITIAL_INDEX","itemEndIndexRef","draggingItemRef","placeholderItemRef","siblingItemsRef","initializeItems","draggingEl","draggingElRect","getBoundingClientRect","children","parentElement","Array","prototype","forEach","call","el","index","getAttribute","DATA_DRAGGABLE_PLACEHOLDER_KEY","push","shifted","setInitialPlaceholderItemStyles","setInitialDraggingItemStyles","setInitialSiblingItemStyles","cleanupItems","unsetInitialPlaceholderItemStyles","unsetInitialDraggingItemStyles","unsetInitialSiblingItemStyles","swappedItemIndexRange","from","to","getShiftAndUnshiftItemsPreparedData","clientY","shiftItemEls","unshiftItemEls","siblingItem","isOverEl","isUnderEl","getTargetIsOverOrUnderElData","setShiftAndUnshiftItemStyles","setSiblingItemsShiftStyles","schedulingAutoScrollTimeoutIdRef","clearSchedulingAutoScrollTimeout","clearTimeout","tryAutoScroll","getAutoScrollingData","shouldScrolling","y","schedulingAutoScroll","setTimeout","AUTO_SCROLL_START_DELAY","onDragStart","event","originalEvent","stopPropagation","preventDefault","onDragMove","shiftY","isRunning","setDraggingItemShiftStyles","prevDragging","onDragEnd","swappedItemRange","handleScroll","useCallback","nextScrollTop","scrollDiff","clientYWithScrollOffset","useIsomorphicLayoutEffect","recalculateOnScroll","scrollEl","addEventListener","removeEventListener","componentWillUnmount"],"mappings":"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"}