{"version":3,"sources":["../../../../../src/components/BaseGallery/CarouselBase/helpers.ts"],"sourcesContent":["import { GallerySlidesState } from '../types';\nimport { SLIDE_THRESHOLD } from './constants';\nimport { LoopPoint, SlidesManagerState } from './types';\n\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent(\n  targetIndex: number,\n  slidesManager: SlidesManagerState,\n  isCenterWithCustomWidth: boolean,\n) {\n  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {\n    return 0;\n  }\n\n  const targetSlide = slidesManager.slides[targetIndex];\n\n  if (targetSlide) {\n    const { coordX, width } = targetSlide;\n\n    if (isCenterWithCustomWidth) {\n      return slidesManager.viewportOffsetWidth / 2 - coordX - width / 2;\n    }\n\n    return -1 * coordX;\n  }\n\n  return 0;\n}\n\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\nexport function getShiftedIndexes(\n  direction: 1 | -1,\n  slides: GallerySlidesState[],\n  availableWidth: number,\n) {\n  let gap = availableWidth;\n  const shiftedSlideIndexes = [];\n  const startIndex = direction === 1 ? 0 : slides.length - 1;\n  const endIndex = direction === 1 ? slides.length - 1 : 0;\n\n  for (\n    let i = startIndex;\n    (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0;\n    i += direction\n  ) {\n    const slideWidth = slides[i].width;\n\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n\n  return shiftedSlideIndexes;\n}\n\nexport function calculateLoopPoints(\n  indexes: number[],\n  edge: 'start' | 'end',\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n): LoopPoint[] {\n  const { contentSize, slides, snaps } = slidesManager;\n  const isStartEdge = edge === 'start';\n  const offset = isStartEdge ? -contentSize : contentSize;\n\n  return indexes.map((index) => {\n    const initial = isStartEdge ? 0 : -contentSize;\n    const altered = isStartEdge ? contentSize : 0;\n    const loopPoint = isStartEdge\n      ? snaps[index] + containerWidth + offset\n      : snaps[index] - slides[index].width + offset - snaps[0];\n\n    return {\n      index,\n      target: (currentLocation) => {\n        return currentLocation >= loopPoint ? initial : altered;\n      },\n    };\n  });\n}\n\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\nexport function getLoopPoints(slidesManager: SlidesManagerState, containerWidth: number) {\n  const { slides, snaps } = slidesManager;\n  const startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);\n  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);\n\n  return [\n    ...calculateLoopPoints(endShiftedIndexes, 'start', slidesManager, containerWidth),\n    ...calculateLoopPoints(startShiftedIndexes, 'end', slidesManager, containerWidth),\n  ];\n}\n\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex(\n  slides: GallerySlidesState[],\n  slideIndex: number,\n  currentShiftX: number,\n  currentShiftXDelta: number,\n) {\n  const shift = currentShiftX + currentShiftXDelta;\n  const direction = currentShiftXDelta < 0 ? 1 : -1;\n\n  // Находим ближайшую границу слайда к текущему отступу\n  let targetIndex = slides.reduce((val: number, item: GallerySlidesState, index: number) => {\n    const previousValue = Math.abs(slides[val].coordX + shift);\n    const currentValue = Math.abs(item.coordX + shift);\n\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n\n  if (targetIndex === slideIndex) {\n    let targetSlide = slideIndex + direction;\n\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    return direction < 0\n      ? (targetSlide + slides.length) % slides.length\n      : targetSlide % slides.length;\n  }\n\n  return targetIndex;\n}\n"],"names":["calculateIndent","calculateLoopPoints","getLoopPoints","getShiftedIndexes","getTargetIndex","targetIndex","slidesManager","isCenterWithCustomWidth","isFullyVisible","slides","length","targetSlide","coordX","width","viewportOffsetWidth","direction","availableWidth","gap","shiftedSlideIndexes","startIndex","endIndex","i","slideWidth","push","indexes","edge","containerWidth","contentSize","snaps","isStartEdge","offset","map","index","initial","altered","loopPoint","target","currentLocation","startShiftedIndexes","endShiftedIndexes","slideIndex","currentShiftX","currentShiftXDelta","shift","reduce","val","item","previousValue","Math","abs","currentValue","SLIDE_THRESHOLD"],"mappings":"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"}