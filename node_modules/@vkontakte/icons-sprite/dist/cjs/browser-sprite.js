"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "BrowserSprite", {
    enumerable: true,
    get: function() {
        return BrowserSprite;
    }
});
var _class_call_check = require("@swc/helpers/_/_class_call_check");
var _create_class = require("@swc/helpers/_/_create_class");
var _define_property = require("@swc/helpers/_/_define_property");
var _browsersymbol = require("./browser-symbol");
var namespaceURI = "http://www.w3.org/2000/svg";
var BrowserSprite = /*#__PURE__*/ function() {
    "use strict";
    function BrowserSprite() {
        var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _class_call_check._(this, BrowserSprite);
        _define_property._(this, "symbols", new Map());
        _define_property._(this, "config", {
            attrs: {
                "xmlns": namespaceURI,
                "xmlns:xlink": "http://www.w3.org/1999/xlink",
                "style": "position:absolute;width:0;height:0",
                "aria-hidden": "true"
            }
        });
        _define_property._(this, "node", null);
        Object.assign(this.config.attrs, config.attrs);
    }
    _create_class._(BrowserSprite, [
        {
            key: "push",
            value: function push(symbol) {
                var symbols = this.symbols;
                var existing = symbols.has(symbol.id);
                symbols.set(symbol.id, symbol);
                return !existing;
            }
        },
        {
            key: "add",
            value: function add(symbol) {
                var isNewSymbol = this.push(symbol);
                if (!!this.node && isNewSymbol) {
                    symbol.mount(this.node);
                }
                return isNewSymbol;
            }
        },
        {
            key: "attach",
            value: function attach(target) {
                var _this = this;
                if (!!this.node) {
                    return;
                }
                this.node = target;
                // Already added symbols needs to be mounted
                this.symbols.forEach(function(symbol) {
                    symbol.mount(target);
                });
                // Create symbols from existing DOM nodes, add and mount them
                target.querySelectorAll("symbol").forEach(function(symbolNode) {
                    var symbol = _browsersymbol.BrowserSymbol.createFromExistingNode(symbolNode);
                    _this.add(symbol);
                });
            }
        },
        {
            key: "mount",
            value: function mount(target) {
                var prepend = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (!!this.node) {
                    return this.node;
                }
                this.node = this.render();
                if (prepend && target.childNodes[0]) {
                    target.insertBefore(this.node, target.firstChild);
                } else {
                    target.appendChild(this.node);
                }
                return this.node;
            }
        },
        {
            key: "render",
            value: function render() {
                var el = document.createElementNS(namespaceURI, "svg");
                Object.entries(this.config.attrs).forEach(function(entry) {
                    return el.setAttribute(entry[0], entry[1]);
                });
                this.symbols.forEach(function(symbol) {
                    return el.appendChild(symbol.node);
                });
                return el;
            }
        },
        {
            key: "unmount",
            value: function unmount() {
                this.node && this.node.parentNode && this.node.parentNode.removeChild(this.node);
            }
        }
    ]);
    return BrowserSprite;
}();

//# sourceMappingURL=browser-sprite.js.map