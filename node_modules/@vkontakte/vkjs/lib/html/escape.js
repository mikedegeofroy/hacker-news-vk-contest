"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decodeHTMLEntities: function() {
        return decodeHTMLEntities;
    },
    decodeHTMLEntitiesDeep: function() {
        return decodeHTMLEntitiesDeep;
    },
    decodeHTMLFullEntities: function() {
        return decodeHTMLFullEntities;
    },
    encodeHTMLEntities: function() {
        return encodeHTMLEntities;
    },
    escape: function() {
        return escape;
    },
    outOfBoundsChar: function() {
        return outOfBoundsChar;
    },
    unescape: function() {
        return unescape;
    }
});
var _replacer = require(/* eslint-disable @typescript-eslint/quotes */ "../lib/replacer");
var _codepoints = require("../lib/codepoints");
var _entity = require("./entity");
var escapeReplacer = /*#__PURE__*/ new _replacer.Replacer({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    '"': "&quot;"
});
var unescapeReplacer = /*#__PURE__*/ new _replacer.Replacer({
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"'
});
var namedEntities = {
    "amp;": "&",
    "lt;": "<",
    "gt;": ">",
    "quot;": '"',
    "apos;": "'"
};
/**
 * Safely escape HTML entities such as `&`, `<`, `>`, `"`, and `'`
 * @param {string} input
 */ function escape(input) {
    return escapeReplacer.replace(input);
}
/**
 * Unescape HTML entities such as `&`, `<`, `>`, `"`, and `'`
 * @param {string} input
 */ function unescape(input) {
    return unescapeReplacer.replace(input);
}
var outOfBoundsChar = /*#__PURE__*/ String.fromCharCode(65533);
var ENCODE_REGEX = /(?:[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
function encodeHTMLEntities(input) {
    if (input == null) {
        return "";
    }
    return input.replace(ENCODE_REGEX, function(entity) {
        var code = entity.length > 1 ? (0, _codepoints.getCodePointAt)(entity, 0) : entity.charCodeAt(0);
        return "&#" + String(code) + ";";
    });
}
var DECODE_REGEX = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g;
function decodeString(input, entities) {
    if (typeof input !== "string" || !input) {
        return "";
    }
    return input.replace(DECODE_REGEX, function(entity) {
        if (entity[1] === "#") {
            // We need to have at least "&#.".
            if (entity.length <= 3) {
                return entity;
            }
            var secondChar = entity.charAt(2);
            var code = secondChar === "x" || secondChar === "X" ? parseInt(entity.substr(3).toLowerCase(), 16) : parseInt(entity.substr(2));
            if (code >= 0x10ffff) {
                return outOfBoundsChar;
            }
            if (code > 65535) {
                return (0, _codepoints.fromCodePoint)(code);
            }
            return String.fromCharCode(_codepoints.numericUnicodeMap[code] || code);
        }
        return entities[entity.slice(1)] || entity;
    });
}
function decodeHTMLEntitiesDeep(input) {
    if (typeof input === "string") {
        return decodeHTMLEntities(input);
    }
    if (typeof input === "object") {
        var correctType = Object.prototype.toString.apply(input);
        if (correctType === "[object Array]") {
            return input.map(function(item) {
                return decodeHTMLEntitiesDeep(item);
            });
        }
        if (correctType === "[object Object]") {
            var response = {};
            Object.keys(input).forEach(function(item) {
                response[decodeHTMLEntities(item)] = decodeHTMLEntitiesDeep(input[item]);
            });
            return response;
        }
    }
    return input;
}
/**
 * `decodeHTMLEntities` декодирует зарезервированные HTML-сущности.
 *
 * Если нужна возможность декодировать все сущности, используйте
 * {@link decodeHTMLFullEntities}
 *
 * @param input текст который необходимо декодировать
 * @param entities кастомный словарь сущностей `{'lt;': '<'}`
 */ function decodeHTMLEntities(input) {
    var entities = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : namedEntities;
    return decodeString(input, entities);
}
/**
 * `decodeHTMLFullEntities` декодирует все HTML-сущности.
 *
 * Если вам нужно декодировать не все сущности, используйте
 * {@link decodeHTMLEntities} и кастомный словарь.
 *
 * @param input текст который необходимо декодировать
 */ function decodeHTMLFullEntities(input) {
    (0, _entity.buildFullNamedEntities)();
    return decodeString(input, _entity.fullNamedEntities);
}

//# sourceMappingURL=escape.js.map